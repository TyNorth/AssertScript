const fs = require('fs')
const path = require('path')

/**
 * Generates the content for a .d.ts TypeScript declaration file. (No changes needed here)
 */
function generateDtsContent(schemas) {
  let dtsContent = `// Auto-generated by Assertify. Do not edit.\n`
  dtsContent += `// Generated at ${new Date().toISOString()}\n\n`
  for (const typeName in schemas) {
    dtsContent += `export interface ${typeName} {\n`
    const schema = schemas[typeName]
    for (let key in schema) {
      const rules = schema[key]
      const isOptional = key.endsWith('?')
      const propertyName = isOptional ? key.slice(0, -1) : key
      const type = rules.type
      let tsType = schemas[type] ? type : type === 'array' ? 'any[]' : type
      dtsContent += `  ${propertyName}${isOptional ? '?' : ''}: ${tsType};\n`
    }
    dtsContent += `}\n\n`
  }
  for (const typeName in schemas) {
    dtsContent += `export function validate${typeName}(data: any): data is ${typeName};\n`
  }
  return dtsContent
}

/**
 * Generates the JavaScript validation functions as a single string. (No changes needed here)
 */
function generateValidatorsString(schemas) {
  let outputCode = `// THIS FILE IS AUTO-GENERATED BY ASSERTIFY. DO NOT EDIT.\n`
  outputCode += `// Generated at ${new Date().toISOString()}\n\n`
  for (const typeName in schemas) {
    const schema = schemas[typeName]
    let functionBody = `export function validate${typeName}(data) {\n`
    functionBody += `  if (typeof data !== 'object' || data === null) {\n`
    functionBody += `    throw new Error('${typeName} must be a non-null object.');\n  }\n\n`
    for (let key in schema) {
      const rules = schema[key]
      const isOptional = key.endsWith('?')
      const propertyName = isOptional ? key.slice(0, -1) : key
      const type = rules.type
      let validationLogic = ''
      if (schemas[type]) {
        validationLogic += `    try { validate${type}(data.${propertyName}); } catch (e) { throw new Error("Validation failed for ${typeName}.${propertyName}: " + e.message); }\n`
      } else {
        const typeCheck =
          type === 'array'
            ? `!Array.isArray(data.${propertyName})`
            : `typeof data.${propertyName} !== '${type}'`
        validationLogic += `    if (${typeCheck}) { throw new Error("Validation failed for ${typeName}.${propertyName}: expected type '${type}' but got '" + (typeof data.${propertyName}) + "'."); }\n`
      }
      if (type === 'string') {
        if (rules.minLength !== undefined)
          validationLogic += `    if (data.${propertyName}.length < ${rules.minLength}) { throw new Error("Validation failed for ${typeName}.${propertyName}: must be at least ${rules.minLength} characters long."); }\n`
        if (rules.maxLength !== undefined)
          validationLogic += `    if (data.${propertyName}.length > ${rules.maxLength}) { throw new Error("Validation failed for ${typeName}.${propertyName}: must be no more than ${rules.maxLength} characters long."); }\n`
        if (rules.pattern)
          validationLogic += `    if (!/${rules.pattern}/.test(data.${propertyName})) { throw new Error("Validation failed for ${typeName}.${propertyName}: does not match required format."); }\n`
        if (rules.enum)
          validationLogic += `    if (!${JSON.stringify(rules.enum)}.includes(data.${propertyName})) { throw new Error("Validation failed for ${typeName}.${propertyName}: must be one of [${rules.enum.join(', ')}]."); }\n`
      }
      if (type === 'number') {
        if (rules.min !== undefined)
          validationLogic += `    if (data.${propertyName} < ${rules.min}) { throw new Error("Validation failed for ${typeName}.${propertyName}: must be at least ${rules.min}."); }\n`
        if (rules.max !== undefined)
          validationLogic += `    if (data.${propertyName} > ${rules.max}) { throw new Error("Validation failed for ${typeName}.${propertyName}: must be no more than ${rules.max}."); }\n`
      }
      functionBody += `  if (data.hasOwnProperty('${propertyName}')) {\n${validationLogic}  } else if (!${isOptional}) {\n    throw new Error("Validation failed for ${typeName}: missing required property '${propertyName}'.");\n  }\n\n`
    }
    functionBody += `  return true;\n}\n`
    outputCode += functionBody
  }
  return outputCode
}

/**
 * The main orchestration function. This now includes the EXPLICIT DELETE step.
 */
function runGeneration() {
  const shouldGenerateDts = process.argv.includes('--dts') || process.argv.includes('--watch')
  console.log('\n--- Running Assertify Generation ---')

  try {
    const typesFilePath = path.join(__dirname, 'types.json')
    const outputFilePath = path.join(__dirname, 'src/validators.js')
    const dtsOutputFilePath = path.join(__dirname, 'src/validators.d.ts')

    // --- NEW: Explicitly delete old files to guarantee a clean slate ---
    if (fs.existsSync(outputFilePath)) fs.unlinkSync(outputFilePath)
    if (fs.existsSync(dtsOutputFilePath)) fs.unlinkSync(dtsOutputFilePath)
    console.log('Cleared old generated files.')
    // -----------------------------------------------------------------

    const schemas = JSON.parse(fs.readFileSync(typesFilePath, 'utf8'))

    const outputCode = generateValidatorsString(schemas)
    fs.writeFileSync(outputFilePath, outputCode, 'utf8')
    console.log(`✅ Wrote: ${outputFilePath}`)

    if (shouldGenerateDts) {
      const dtsContent = generateDtsContent(schemas)
      fs.writeFileSync(dtsOutputFilePath, dtsContent, 'utf8')
      console.log(`✅ Wrote: ${dtsOutputFilePath}`)
    }
    console.log('--- Generation Complete ---')
  } catch (error) {
    console.error('❌ Assertify Error:', error.message)
    if (!process.argv.includes('--watch')) {
      process.exit(1)
    }
  }
}

// --- Exports for Testing (No changes needed here) ---
module.exports = {
  generateValidatorsString,
  generateDtsContent,
}

// --- Script Entry Point (No changes needed here) ---
if (require.main === module) {
  const yargs = require('yargs/yargs')
  const { hideBin } = require('yargs/helpers')

  const argv = yargs(hideBin(process.argv))
    .option('watch', { alias: 'w', type: 'boolean', description: 'Watch for changes' })
    .option('dts', { alias: 'd', type: 'boolean', description: 'Generate .d.ts file' })
    .help()
    .alias('help', 'h').argv

  if (argv.watch) {
    const chokidar = require('chokidar')
    const typesFilePath = path.join(__dirname, 'types.json')
    console.log(`👀 Assertify is now watching ${typesFilePath} for changes...`)

    runGeneration() // Initial run

    const watcher = chokidar.watch(typesFilePath, { persistent: true, ignoreInitial: true })
    watcher.on('change', () => runGeneration())
  } else {
    runGeneration()
  }
}
