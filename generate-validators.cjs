// Using CommonJS 'require' because this is a Node.js script.
const fs = require('fs')
const path = require('path')

/**
 * Generates the content for a .d.ts TypeScript declaration file.
 * @param {object} schemas The parsed schemas object from types.json.
 * @returns {string} A string containing the full content of the .d.ts file.
 */
function generateDtsContent(schemas) {
  let dtsContent = `// Auto-generated by Assertify. Do not edit.\n`
  dtsContent += `// Generated at ${new Date().toISOString()}\n\n`

  // 1. First, generate all the interface definitions
  for (const typeName in schemas) {
    dtsContent += `export interface ${typeName} {\n`
    const schema = schemas[typeName]
    for (let key in schema) {
      const rules = schema[key]
      const isOptional = key.endsWith('?')
      const propertyName = isOptional ? key.slice(0, -1) : key
      const type = rules.type

      let tsType
      if (schemas[type]) {
        tsType = type
      } else {
        tsType = type === 'array' ? 'any[]' : type
      }
      dtsContent += `  ${propertyName}${isOptional ? '?' : ''}: ${tsType};\n`
    }
    dtsContent += `}\n\n`
  }

  // 2. Second, generate the signatures for all the validation functions
  for (const typeName in schemas) {
    dtsContent += `export function validate${typeName}(data: any): data is ${typeName};\n`
  }

  return dtsContent
}

/**
 * Generates the JavaScript validation functions as a single string.
 * This is a pure function, making it easy to test.
 * @param {object} schemas The parsed schemas object from types.json.
 * @returns {string} The complete JavaScript code for the validators.js file.
 */
function generateValidatorsString(schemas) {
  let outputCode = `// THIS FILE IS AUTO-GENERATED BY ASSERTIFY. DO NOT EDIT.\n`
  outputCode += `// Generated at ${new Date().toISOString()}\n\n`

  for (const typeName in schemas) {
    const schema = schemas[typeName]
    const functionName = `validate${typeName}`

    let functionBody = `export function ${functionName}(data) {\n`
    functionBody += `  if (typeof data !== 'object' || data === null) {\n`
    functionBody += `    throw new Error('${typeName} must be a non-null object.');\n  }\n\n`

    for (let key in schema) {
      const rules = schema[key]
      const isOptional = key.endsWith('?')
      const propertyName = isOptional ? key.slice(0, -1) : key
      const type = rules.type

      let validationLogic = ''

      // 1. Basic type validation
      if (schemas[type]) {
        // It's a nested custom type
        validationLogic += `    try {\n`
        validationLogic += `      validate${type}(data.${propertyName});\n`
        validationLogic += `    } catch (e) {\n`
        validationLogic += `      throw new Error("Validation failed for ${typeName}.${propertyName}: " + e.message);\n`
        validationLogic += `    }\n`
      } else {
        // It's a primitive type
        const typeCheck =
          type === 'array'
            ? `!Array.isArray(data.${propertyName})`
            : `typeof data.${propertyName} !== '${type}'`
        validationLogic += `    if (${typeCheck}) {\n`
        validationLogic += `      throw new Error("Validation failed for ${typeName}.${propertyName}: expected type '${type}' but got '" + (typeof data.${propertyName}) + "'.");\n`
        validationLogic += `    }\n`
      }

      // 2. Content-based validation rules
      if (type === 'string') {
        if (rules.minLength !== undefined) {
          validationLogic += `    if (data.${propertyName}.length < ${rules.minLength}) {\n`
          validationLogic += `      throw new Error("Validation failed for ${typeName}.${propertyName}: must be at least ${rules.minLength} characters long.");\n    }\n`
        }
        if (rules.maxLength !== undefined) {
          validationLogic += `    if (data.${propertyName}.length > ${rules.maxLength}) {\n`
          validationLogic += `      throw new Error("Validation failed for ${typeName}.${propertyName}: must be no more than ${rules.maxLength} characters long.");\n    }\n`
        }
        if (rules.pattern) {
          validationLogic += `    if (!/${rules.pattern}/.test(data.${propertyName})) {\n`
          validationLogic += `      throw new Error("Validation failed for ${typeName}.${propertyName}: does not match required format.");\n    }\n`
        }
        if (rules.enum) {
          const enumString = JSON.stringify(rules.enum)
          validationLogic += `    if (!${enumString}.includes(data.${propertyName})) {\n`
          validationLogic += `      throw new Error("Validation failed for ${typeName}.${propertyName}: must be one of [${rules.enum.join(', ')}].");\n    }\n`
        }
      }
      if (type === 'number') {
        if (rules.min !== undefined) {
          validationLogic += `    if (data.${propertyName} < ${rules.min}) {\n`
          validationLogic += `      throw new Error("Validation failed for ${typeName}.${propertyName}: must be at least ${rules.min}.");\n    }\n`
        }
        if (rules.max !== undefined) {
          validationLogic += `    if (data.${propertyName} > ${rules.max}) {\n`
          validationLogic += `      throw new Error("Validation failed for ${typeName}.${propertyName}: must be no more than ${rules.max}.");\n    }\n`
        }
      }

      functionBody += `  if (data.hasOwnProperty('${propertyName}')) {\n`
      functionBody += validationLogic
      functionBody += `  } else if (!${isOptional}) {\n`
      functionBody += `    throw new Error("Validation failed for ${typeName}: missing required property '${propertyName}'.");\n`
      functionBody += `  }\n\n`
    }

    functionBody += `  return true;\n`
    functionBody += `}\n`
    outputCode += functionBody
  }
  return outputCode
}

/**
 * The main orchestration function. Reads schemas, calls generators, and writes files.
 * This function handles all logging and file system side effects.
 */
function runGeneration(argv) {
  // Accept argv as an argument
  // Check flags from the argv object, not process.argv
  const shouldGenerateDts = argv.dts || argv.watch

  console.log('\n--- Running Assertify Generation ---')
  try {
    // ... (The rest of the file reading and code generation logic remains exactly the same) ...
    // ... (No other changes are needed inside the try...catch block) ...
  } catch (error) {
    console.error('❌ Assertify Error: Generation failed.', error)
    if (!argv.watch) {
      // Check the flag from the argv object
      process.exit(1)
    }
  }

  // --- NEW: The watcher logic is now started from within runGeneration ---
  if (argv.watch) {
    // We require chokidar here so it's only loaded when needed
    const chokidar = require('chokidar')
    const typesFilePath = path.join(__dirname, 'types.json')

    console.log(`👀 Assertify is now watching ${typesFilePath} for changes...`)

    const watcher = chokidar.watch(typesFilePath, { persistent: true })

    // We only need the change event, as the first run has already happened
    watcher.on('change', (path) => {
      console.log(`\nFile change detected: ${path}`)
      // Pass the same argv to subsequent runs
      runGeneration(argv)
    })
  }
}

// --- Export the pure functions for testing ---
module.exports = {
  generateValidatorsString,
  generateDtsContent,
}

// --- Script Entry Point ---
// This block only runs when the script is executed directly from the command line.
// It does NOT run when the file is imported (e.g., by a test file).
if (require.main === module) {
  // Use yargs to parse command-line arguments
  const yargs = require('yargs/yargs')
  const { hideBin } = require('yargs/helpers')

  const argv = yargs(hideBin(process.argv))
    .option('watch', {
      alias: 'w',
      type: 'boolean',
      description: 'Watch for changes in types.json and regenerate files automatically',
    })
    .option('dts', {
      alias: 'd',
      type: 'boolean',
      description: 'Generate the corresponding .d.ts TypeScript declaration file',
    })
    .help()
    .alias('help', 'h').argv

  // We now pass the parsed arguments directly to the generation function
  if (argv.watch) {
    const chokidar = require('chokidar')
    const typesFilePath = path.join(__dirname, 'types.json')

    console.log(`👀 Assertify is now watching ${typesFilePath} for changes...`)

    const watcher = chokidar.watch(typesFilePath, { persistent: true })

    runGeneration(argv) // Initial run with argv

    watcher.on('change', () => {
      runGeneration(argv) // Subsequent runs with argv
    })
  } else {
    runGeneration(argv) // Single run with argv
  }

  // The watcher logic also moves inside the runGeneration function
}
